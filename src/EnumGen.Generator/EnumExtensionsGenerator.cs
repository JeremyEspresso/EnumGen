using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Diagnostics;
using System.Text;

namespace EnumGen.Generator
{
	[Generator]
	public class EnumExtensionsGenerator : ISourceGenerator
	{
		public void Initialize(GeneratorInitializationContext context)
		{
			context.RegisterForSyntaxNotifications(() => new EnumSyntaxReceiver());
		}

		public void Execute(GeneratorExecutionContext context)
		{
			var syntaxReceiver = (EnumSyntaxReceiver)context.SyntaxContextReceiver;

			foreach (var @enum in syntaxReceiver.Enums)
			{
				var enumType = @enum.Item1;
				var enumValues = @enum.Item2;
				var sb = new StringBuilder();

				sb.AppendLine("switch (@enum)");
				sb.AppendLine("\t\t\t{");
				foreach (var value in enumValues)
				{
					sb.AppendLine($"\t\t\t\tcase {enumType.Name}.{value.Identifier}:");
					sb.AppendLine($"\t\t\t\t\treturn nameof({enumType.Name}.{value.Identifier});");
				}
				sb.AppendLine("\t\t\t\tdefault:");
				sb.AppendLine("\t\t\t\t\tthrow new ArgumentOutOfRangeException(nameof(@enum), @enum, null);");
				sb.AppendLine("\t\t\t}");

				var enumNamespace = enumType.ContainingNamespace is null ? "EnumGen.Generated" : enumType.ContainingNamespace.ToDisplayString();

				var sourceText = SourceText.From($@"
// <auto-generated>
// This code was generated by EnumGen.
using System;

namespace {enumNamespace}
{{
	public static partial class {enumType.Name}Extensions
	{{
		public static string MemberString(this {enumType.Name} @enum)
		{{
			{sb}
		}}
	}}
}}
", Encoding.UTF8);

				context.AddSource($"{enumNamespace}.{enumType.Name}.generated.cs", sourceText);
			}
		}
	}
}
